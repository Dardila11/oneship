{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Monorepo Structure",
        "description": "Initialize the monorepo structure with Turborepo for the OneShip project, including the core packages: create-oneship-app, cli, core, and templates.",
        "details": "1. Initialize a new repository with Git\n2. Set up Turborepo using pnpm:\n   ```bash\n   pnpm init\n   pnpm add -D turbo typescript @types/node\n   ```\n3. Create the monorepo structure:\n   ```\n   oneship/\n   ├── packages/\n   │   ├── create-oneship-app/     # CLI to scaffold new projects\n   │   ├── cli/                    # Main CLI (e.g., `oneship add auth`)\n   │   ├── core/                   # Shared utilities and helpers\n   │   └── templates/              # Source for generating project and features\n   ├── examples/                   # Sample apps\n   ├── docs/                       # Documentation\n   ├── package.json\n   ├── turbo.json\n   └── README.md\n   ```\n4. Configure turbo.json with appropriate pipelines for build, test, and lint\n5. Set up shared TypeScript configuration\n6. Configure package.json with appropriate scripts and workspaces",
        "testStrategy": "Verify the monorepo structure is correctly set up by running `pnpm install` and ensuring all packages can be built with `pnpm build`. Test workspace dependencies by importing a module from one package into another.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Git Repository and Base Project Structure",
            "description": "Set up the initial Git repository and create the base folder structure for the monorepo.",
            "dependencies": [],
            "details": "1. Create a new directory for the project\n2. Initialize Git repository with `git init`\n3. Create the initial folder structure including packages/, examples/, and docs/ directories\n4. Create a basic README.md with project overview\n5. Add .gitignore file with appropriate patterns for Node.js projects\n6. Make initial commit",
            "status": "done",
            "testStrategy": "Verify the directory structure is created correctly and Git repository is properly initialized."
          },
          {
            "id": 2,
            "title": "Configure Package Manager and Turborepo",
            "description": "Set up pnpm as the package manager and initialize Turborepo for monorepo management.",
            "dependencies": [
              1
            ],
            "details": "1. Initialize package.json with `pnpm init`\n2. Install Turborepo and TypeScript dependencies: `pnpm add -D turbo typescript @types/node`\n3. Configure pnpm workspaces in package.json\n4. Create turbo.json with initial pipeline configuration for build, test, and lint\n5. Set up shared tsconfig.json with base TypeScript configuration\n6. Configure root package.json scripts for common operations",
            "status": "done",
            "testStrategy": "Run `pnpm install` to verify workspace configuration is correct and dependencies install properly."
          },
          {
            "id": 3,
            "title": "Create Core and CLI Package Structures",
            "description": "Set up the core and CLI packages with their initial configurations.",
            "dependencies": [
              2
            ],
            "details": "1. Create packages/core/ directory with its own package.json\n2. Set up TypeScript configuration for the core package\n3. Create packages/cli/ directory with its own package.json\n4. Configure the CLI package with necessary dependencies\n5. Create basic entry points for both packages\n6. Set up package.json scripts for both packages that integrate with Turborepo pipelines",
            "status": "done",
            "testStrategy": "Verify that both packages can be built using the Turborepo pipeline and have correct dependencies."
          },
          {
            "id": 4,
            "title": "Implement Create-OneShip-App Package",
            "description": "Create the scaffolding package that will be used to initialize new OneShip projects.",
            "dependencies": [
              3
            ],
            "details": "1. Create packages/create-oneship-app/ directory with its own package.json\n2. Configure package.json with bin entry for CLI execution\n3. Set up TypeScript configuration\n4. Create basic CLI structure with commander or similar\n5. Implement skeleton for project initialization logic\n6. Configure build process to produce executable package",
            "status": "done",
            "testStrategy": "Test the package locally by linking it (`pnpm link`) and verifying it can be executed as a command-line tool."
          },
          {
            "id": 5,
            "title": "Set Up Templates Package and Integration",
            "description": "Create the templates package and integrate it with the create-oneship-app tool.",
            "dependencies": [
              4
            ],
            "details": "1. Create packages/templates/ directory with its own package.json\n2. Create initial template structure for basic project\n3. Set up file organization for different template types\n4. Implement template loading mechanism in core package\n5. Connect create-oneship-app to use templates package\n6. Add documentation for template structure and usage",
            "status": "done",
            "testStrategy": "Test the integration by using create-oneship-app to generate a project from a template and verify the output matches expectations."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Core Package",
        "description": "Develop the core package with shared utilities and helpers that will be used across the CLI and template generation.",
        "details": "1. Initialize the core package with TypeScript:\n   ```bash\n   cd packages/core\n   pnpm init\n   pnpm add -D typescript @types/node\n   ```\n2. Implement file system utilities:\n   ```typescript\n   // src/fs.ts\n   import fs from 'fs-extra';\n   \n   export const createDirectory = async (path: string): Promise<void> => {\n     await fs.ensureDir(path);\n   };\n   \n   export const writeFile = async (path: string, content: string): Promise<void> => {\n     await fs.outputFile(path, content);\n   };\n   ```\n3. Implement template rendering utilities using a templating engine like EJS:\n   ```typescript\n   // src/template.ts\n   import ejs from 'ejs';\n   \n   export const renderTemplate = (template: string, data: Record<string, any>): string => {\n     return ejs.render(template, data);\n   };\n   ```\n4. Create package management utilities:\n   ```typescript\n   // src/package.ts\n   import { execa } from 'execa';\n   import fs from 'fs-extra';\n   \n   export const installDependencies = async (dependencies: string[], dev = false): Promise<void> => {\n     const args = ['add', ...(dev ? ['-D'] : []), ...dependencies];\n     await execa('pnpm', args, { stdio: 'inherit' });\n   };\n   \n   export const updatePackageJson = async (path: string, updates: Record<string, any>): Promise<void> => {\n     const pkg = await fs.readJson(path);\n     const updatedPkg = { ...pkg, ...updates };\n     await fs.writeJson(path, updatedPkg, { spaces: 2 });\n   };\n   ```\n5. Implement logging utilities with colors and formatting\n6. Create configuration management utilities for .env files\n7. Export all utilities from an index.ts file",
        "testStrategy": "Write unit tests for each utility function using Jest or Vitest. Test file operations with mock file systems. Test template rendering with various inputs and expected outputs. Test package management utilities by mocking execa calls.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement logging utilities",
            "description": "Create a logging module with colored output and formatting options",
            "dependencies": [],
            "details": "Implement a Logger class with methods for different log levels (info, warn, error, debug). Use a library like chalk for colored output. Include options for log formatting and timestamp inclusion.",
            "status": "done",
            "testStrategy": "Write unit tests for each log level and formatting option"
          },
          {
            "id": 2,
            "title": "Create configuration management utilities",
            "description": "Develop utilities for managing .env files and configuration settings",
            "dependencies": [],
            "details": "Implement functions to read from .env files, parse environment variables, and provide a centralized configuration object. Include support for different environments (development, production, etc.).",
            "status": "done",
            "testStrategy": "Create test .env files and verify correct parsing and configuration loading"
          },
          {
            "id": 3,
            "title": "Implement error handling utilities",
            "description": "Create a set of custom error classes and error handling functions",
            "dependencies": [
              1
            ],
            "details": "Define custom error classes for different types of errors (e.g., ValidationError, NetworkError). Implement a global error handler that logs errors using the logging utilities and provides appropriate error responses.",
            "status": "done",
            "testStrategy": "Test error throwing and handling for various scenarios, including integration with the logging utilities"
          },
          {
            "id": 4,
            "title": "Develop utility functions for string manipulation",
            "description": "Create a set of helper functions for common string operations",
            "dependencies": [],
            "details": "Implement functions for camelCase, snake_case, and kebab-case conversions, string truncation, pluralization, and other common string manipulations that may be useful across the project.",
            "status": "done",
            "testStrategy": "Write unit tests for each string manipulation function with various input scenarios"
          },
          {
            "id": 5,
            "title": "Create an index.ts file to export all utilities",
            "description": "Consolidate all utility exports into a single index.ts file for easy importing",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create an index.ts file that imports and re-exports all utility functions and classes from the various modules (fs, template, package, logging, configuration, error handling, string manipulation). Ensure proper TypeScript typing for all exports.",
            "status": "done",
            "testStrategy": "Verify that all utilities can be imported correctly from the index file in a test script"
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop CLI Package",
        "description": "Create the main CLI package that will handle commands like 'add auth', 'add db', etc. using Commander.js for command routing.",
        "details": "1. Initialize the CLI package:\n   ```bash\n   cd packages/cli\n   pnpm init\n   pnpm add commander prompts fs-extra execa\n   pnpm add -D typescript @types/node @types/fs-extra\n   ```\n2. Create the main CLI entry point:\n   ```typescript\n   // src/index.ts\n   #!/usr/bin/env node\n   import { Command } from 'commander';\n   import { version } from '../package.json';\n   \n   const program = new Command();\n   \n   program\n     .name('oneship')\n     .description('CLI toolkit for building and deploying modern web apps')\n     .version(version);\n   \n   // Import and register commands\n   import { registerAddCommand } from './commands/add';\n   \n   registerAddCommand(program);\n   \n   program.parse(process.argv);\n   ```\n3. Implement the 'add' command with subcommands for auth, db, env, and feature:\n   ```typescript\n   // src/commands/add.ts\n   import { Command } from 'commander';\n   import prompts from 'prompts';\n   import { addAuth } from '../features/auth';\n   import { addDatabase } from '../features/database';\n   import { addEnv } from '../features/env';\n   import { addFeature } from '../features/feature';\n   \n   export function registerAddCommand(program: Command): void {\n     const add = program.command('add');\n     \n     add.command('auth')\n       .description('Add authentication to your project')\n       .option('--using <provider>', 'Auth provider (clerk, next-auth, supabase)')\n       .action(async (options) => {\n         // If provider not specified, prompt user\n         if (!options.using) {\n           const response = await prompts({\n             type: 'select',\n             name: 'provider',\n             message: 'Select an auth provider:',\n             choices: [\n               { title: 'Clerk', value: 'clerk' },\n               { title: 'NextAuth.js', value: 'next-auth' },\n               { title: 'Supabase Auth', value: 'supabase' }\n             ]\n           });\n           options.using = response.provider;\n         }\n         \n         await addAuth(options.using);\n       });\n     \n     // Similar implementations for db, env, and feature commands\n   }\n   ```\n4. Implement feature modules for auth, database, env, and custom features\n5. Create utility functions for detecting project type and structure\n6. Set up bin entry in package.json for CLI execution\n7. Implement error handling and validation for commands",
        "testStrategy": "Test the CLI commands using mock file systems and spying on execa calls. Write integration tests that verify the correct templates are selected and files are generated. Test the interactive prompts by mocking user input. Verify error handling by testing with invalid inputs and configurations.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up CLI package structure and entry point",
            "description": "Initialize the CLI package with necessary dependencies and create the main entry point file that will serve as the command router using Commander.js.",
            "dependencies": [],
            "details": "1. Create the package directory structure with src/ folder\n2. Initialize package.json with pnpm init\n3. Install required dependencies (commander, prompts, fs-extra, execa)\n4. Install dev dependencies (typescript, @types/node, @types/fs-extra)\n5. Create tsconfig.json with appropriate settings\n6. Implement the main src/index.ts file with Commander.js setup\n7. Configure package.json with bin entry pointing to the compiled index.js\n8. Set up build script using tsc",
            "status": "done",
            "testStrategy": "Verify the CLI can be executed and displays help information correctly"
          },
          {
            "id": 2,
            "title": "Implement 'add' command framework",
            "description": "Create the base structure for the 'add' command and its subcommand registration system.",
            "dependencies": [],
            "details": "1. Create src/commands/add.ts file\n2. Implement the registerAddCommand function that takes a Commander instance\n3. Set up the base 'add' command\n4. Create placeholder subcommands for auth, db, env, and feature\n5. Implement the command registration pattern\n6. Import and register the add command in the main index.ts file\n7. Set up the basic action handlers with prompts for options",
            "status": "done",
            "testStrategy": "Test that 'add' command and subcommands appear in help output and can be invoked without errors"
          },
          {
            "id": 3,
            "title": "Implement auth and database feature modules",
            "description": "Create the feature modules for authentication and database integration that will be used by the 'add auth' and 'add db' commands.",
            "dependencies": [],
            "details": "1. Create src/features/auth.ts and src/features/database.ts\n2. Implement addAuth function with support for different providers (clerk, next-auth, supabase)\n3. Implement addDatabase function with support for different databases (postgres, mysql, mongodb)\n4. Create templates for configuration files that will be added to user projects\n5. Implement provider-specific logic for each auth option\n6. Implement database-specific logic for each database option\n7. Add validation for project compatibility",
            "status": "done",
            "testStrategy": "Create mock project structures and verify that auth and database features can be correctly added"
          },
          {
            "id": 4,
            "title": "Implement env and custom feature modules",
            "description": "Create the feature modules for environment variables and custom feature templates that will be used by the 'add env' and 'add feature' commands.",
            "dependencies": [],
            "details": "1. Create src/features/env.ts and src/features/feature.ts\n2. Implement addEnv function for setting up environment variables\n3. Implement addFeature function for adding custom features\n4. Create templates for .env files and related configuration\n5. Set up a system for managing custom feature templates\n6. Implement file modification utilities for updating existing files\n7. Add support for different project structures",
            "status": "done",
            "testStrategy": "Test adding environment variables to different project types and verify custom feature template application"
          },
          {
            "id": 5,
            "title": "Implement project utilities and error handling",
            "description": "Create utility functions for project detection, validation, and implement robust error handling throughout the CLI.",
            "dependencies": [],
            "details": "1. Create src/utils/project.ts for project-related utilities\n2. Implement functions to detect project type (Next.js, React, etc.)\n3. Create src/utils/errors.ts for standardized error handling\n4. Implement validation functions to check if commands can be executed in current project\n5. Add colorful console output for errors and success messages\n6. Implement logging utilities\n7. Add graceful error handling for all commands\n8. Create a final integration test script that verifies all commands",
            "status": "done",
            "testStrategy": "Test error scenarios like invalid project structures, missing dependencies, and verify helpful error messages are displayed"
          }
        ]
      },
      {
        "id": 4,
        "title": "Create Template Package",
        "description": "Develop the templates package containing source files for generating projects and features, including auth integrations, database setups, and feature scaffolding. This package will be part of the engine that handles the business logic for scaffolding OneShip projects.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "medium",
        "details": "1. Initialize the templates package:\n   ```bash\n   cd packages/templates\n   pnpm init\n   ```\n2. Create folder structure for different templates:\n   ```\n   templates/\n   ├── project/              # Base project templates\n   │   ├── next-app/        # Next.js app router template\n   │   └── next-pages/      # Next.js pages router template\n   ├── auth/                # Auth integration templates\n   │   ├── clerk/\n   │   ├── next-auth/\n   │   └── supabase/\n   │   ├── lucia/           # Lucia auth (in development)\n   │   └── better-auth/     # BetterAuth option\n   ├── db/                  # Database integration templates\n   │   ├── prisma/\n   │   ├── drizzle/\n   │   └── supabase/\n   ├── features/            # Feature templates\n   │   ├── dashboard/\n   │   └── profile/\n   └── env/                 # Environment configuration templates\n   ```\n3. Create base Next.js app template with the following structure:\n   ```\n   next-app/\n   ├── app/\n   │   ├── layout.tsx\n   │   └── page.tsx\n   ├── features/\n   │   └── core/\n   │       ├── layout/\n   │       ├── components/\n   │       └── hooks/\n   ├── public/\n   ├── styles/\n   ├── .env.example\n   ├── next.config.js\n   ├── package.json\n   ├── tailwind.config.ts\n   ├── tsconfig.json\n   └── README.md\n   ```\n4. Implement auth templates for different providers (Next-Auth, Clerk, Supabase, Lucia, BetterAuth)\n5. Create database templates for Prisma, Drizzle, and Supabase\n6. Develop feature templates for common features like dashboard, profile, etc.\n7. Implement environment configuration templates\n8. Use EJS or similar templating for dynamic content\n9. Design the templates to work within the engine package that will contain all business logic for scaffolding",
        "testStrategy": "Verify template files are correctly structured and contain valid syntax. Test template rendering with different variables and configurations. Ensure generated files are valid TypeScript/JavaScript and can be compiled. Test integration with the engine package to ensure templates are correctly applied. Verify that the templates support all the interactive options shown in the CLI prompts.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement base Next.js app templates",
            "description": "Create base templates for Next.js app router and pages router projects",
            "status": "pending",
            "dependencies": [],
            "details": "Develop the base Next.js app templates for both app router and pages router, including the folder structure, essential files, and basic configurations. Ensure the templates include placeholders for auth and database integrations.",
            "testStrategy": "Manually verify the structure and content of the created templates. Test by generating a project using each template and ensuring it builds and runs without errors."
          },
          {
            "id": 2,
            "title": "Develop auth integration templates",
            "description": "Create templates for Next-Auth, Clerk, Supabase, Lucia, and BetterAuth integrations",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Implement auth templates for Next-Auth, Clerk, Supabase, Lucia (marked as in development), and BetterAuth. Include necessary configuration files, API routes, and components for each auth provider. Use placeholders for sensitive information like API keys.",
            "testStrategy": "Create test projects using each auth template. Verify that authentication flows (sign up, sign in, sign out) work correctly for each provider."
          },
          {
            "id": 3,
            "title": "Create database integration templates",
            "description": "Develop templates for Prisma, Drizzle, and Supabase database integrations",
            "status": "pending",
            "dependencies": [
              1
            ],
            "details": "Implement database templates for Prisma, Drizzle, and Supabase. Include configuration files, schema definitions, and basic CRUD operations for each ORM/database solution. Use placeholders for connection strings and other sensitive data.",
            "testStrategy": "Generate test projects with each database template. Verify that database connections can be established and basic CRUD operations work as expected."
          },
          {
            "id": 4,
            "title": "Implement feature templates",
            "description": "Create templates for common features like dashboard and profile",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Develop feature templates for dashboard and profile components. Include necessary pages, components, and API routes. Ensure these templates can be easily integrated with different auth and database solutions.",
            "testStrategy": "Create test projects that include these feature templates. Verify that the features render correctly and interact properly with the chosen auth and database integrations."
          },
          {
            "id": 5,
            "title": "Set up templating system and package structure",
            "description": "Implement EJS templating and organize the package structure",
            "status": "pending",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Set up EJS or a similar templating system for dynamic content generation. Organize the package structure to include all created templates. Implement a system for combining different templates (base, auth, database, features) into a cohesive project structure.",
            "testStrategy": "Test the templating system by generating projects with various combinations of templates. Ensure that the resulting projects are correctly structured and all placeholders are properly replaced."
          },
          {
            "id": 6,
            "title": "Integrate with engine package architecture",
            "description": "Adapt templates to work within the engine package that contains all business logic",
            "status": "pending",
            "dependencies": [
              5
            ],
            "details": "Refactor the templates to work within the new architecture where the engine package contains all business logic for scaffolding and configuring a OneShip project. Ensure the templates can be easily accessed and used by the engine package without direct dependency on CLI-specific code.",
            "testStrategy": "Verify that the templates can be correctly loaded and processed by the engine package. Test the integration by generating projects through the engine API and ensure all templates are correctly applied."
          },
          {
            "id": 7,
            "title": "Support interactive CLI options",
            "description": "Ensure templates support all options shown in CLI prompts",
            "status": "pending",
            "dependencies": [
              6
            ],
            "details": "Update templates to support all the interactive options shown in the CLI prompts, including project naming, Tailwind CSS integration, and the full range of authentication providers (Next-Auth, Clerk, Supabase Auth, Lucia, BetterAuth, and None).",
            "testStrategy": "Test each template with various combinations of CLI options. Verify that the generated projects correctly implement all selected options and that the templates handle all possible combinations gracefully."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement create-oneship-app Package",
        "description": "Develop the create-oneship-app package that scaffolds new projects with interactive prompts for configuration options.",
        "details": "1. Initialize the create-oneship-app package:\n   ```bash\n   cd packages/create-oneship-app\n   pnpm init\n   pnpm add commander prompts fs-extra execa\n   pnpm add -D typescript @types/node @types/fs-extra\n   ```\n2. Create the main entry point:\n   ```typescript\n   // src/index.ts\n   #!/usr/bin/env node\n   import { Command } from 'commander';\n   import prompts from 'prompts';\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { execa } from 'execa';\n   import { renderTemplate, createDirectory } from '@oneship/core';\n   \n   const program = new Command();\n   \n   program\n     .name('create-oneship-app')\n     .description('Create a new OneShip app')\n     .argument('[name]', 'Project name')\n     .action(async (name) => {\n       // If name not provided, prompt for it\n       if (!name) {\n         const response = await prompts({\n           type: 'text',\n           name: 'name',\n           message: 'What is your project named?',\n           initial: 'my-oneship-app'\n         });\n         name = response.name;\n       }\n       \n       // Prompt for configuration options\n       const options = await prompts([\n         {\n           type: 'select',\n           name: 'language',\n           message: 'JavaScript or TypeScript?',\n           choices: [\n             { title: 'TypeScript', value: 'typescript' },\n             { title: 'JavaScript', value: 'javascript' }\n           ],\n           initial: 0\n         },\n         {\n           type: 'confirm',\n           name: 'tailwind',\n           message: 'Use TailwindCSS?',\n           initial: true\n         },\n         {\n           type: 'confirm',\n           name: 'shadcn',\n           message: 'Add Shadcn UI?',\n           initial: false\n         },\n         {\n           type: 'confirm',\n           name: 'auth',\n           message: 'Include Auth?',\n           initial: false\n         },\n         {\n           type: 'select',\n           name: 'authProvider',\n           message: 'Select auth provider:',\n           choices: [\n             { title: 'Clerk', value: 'clerk' },\n             { title: 'NextAuth.js', value: 'next-auth' },\n             { title: 'Supabase Auth', value: 'supabase' }\n           ],\n           initial: 0,\n           skip: (prev, values) => !values.auth\n         }\n       ]);\n       \n       // Create project directory\n       const projectDir = path.resolve(process.cwd(), name);\n       await createDirectory(projectDir);\n       \n       // Copy base template\n       const templateDir = path.resolve(__dirname, '../templates/project/next-app');\n       await fs.copy(templateDir, projectDir);\n       \n       // Apply configuration options\n       // ...\n       \n       // Install dependencies\n       console.log('Installing dependencies...');\n       await execa('pnpm', ['install'], { cwd: projectDir, stdio: 'inherit' });\n       \n       console.log(`\\nSuccess! Created ${name} at ${projectDir}\\n`);\n       console.log('Next steps:');\n       console.log(`  cd ${name}`);\n       console.log('  pnpm dev');\n     });\n   \n   program.parse(process.argv);\n   ```\n3. Set up bin entry in package.json for CLI execution\n4. Implement template selection and rendering based on user choices\n5. Add support for installing dependencies and initializing Git repository\n6. Implement post-installation instructions and next steps\n7. Add error handling and validation",
        "testStrategy": "Test the CLI with different project names and configuration options. Verify the generated project structure matches the expected output. Test error handling by simulating file system errors and invalid inputs. Ensure the generated project can be built and run successfully.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up package structure and CLI entry point",
            "description": "Initialize the package.json, install dependencies, and create the basic CLI structure with commander and prompts integration.",
            "dependencies": [],
            "details": "1. Run `pnpm init` to create package.json\n2. Install required dependencies (commander, prompts, fs-extra, execa)\n3. Install dev dependencies (typescript, @types/node, @types/fs-extra)\n4. Configure the package.json with bin entry pointing to dist/index.js\n5. Create the basic CLI structure in src/index.ts with commander setup\n6. Set up TypeScript configuration (tsconfig.json)\n7. Add build script to compile TypeScript to JavaScript",
            "status": "pending",
            "testStrategy": "Manually verify the CLI can be executed and displays help information"
          },
          {
            "id": 2,
            "title": "Implement interactive prompts for project configuration",
            "description": "Create the interactive prompts flow to collect user preferences for project configuration including language choice, UI libraries, and auth options.",
            "dependencies": [
              1
            ],
            "details": "1. Implement prompts for project name if not provided as argument\n2. Add language selection prompt (TypeScript/JavaScript)\n3. Add UI library prompts (TailwindCSS, Shadcn UI)\n4. Add authentication prompts with conditional provider selection\n5. Structure the collected options into a configuration object\n6. Add validation for user inputs\n7. Implement a way to save configuration for later reference",
            "status": "pending",
            "testStrategy": "Test different prompt flows including skipped prompts based on previous answers"
          },
          {
            "id": 3,
            "title": "Create project templates and directory structure",
            "description": "Set up the template directory structure and implement the logic to copy and customize templates based on user configuration.",
            "dependencies": [
              2
            ],
            "details": "1. Create a templates directory with base Next.js app structure\n2. Add variant templates for TypeScript and JavaScript\n3. Create template fragments for optional features (Tailwind, Shadcn, Auth providers)\n4. Implement the createDirectory function to set up the project folder\n5. Create the fs-extra copy logic to transfer base templates\n6. Implement template rendering with variable substitution\n7. Add logic to conditionally include files based on selected options",
            "status": "pending",
            "testStrategy": "Verify template generation with different configuration combinations"
          },
          {
            "id": 4,
            "title": "Implement dependency installation and Git initialization",
            "description": "Add functionality to install the appropriate dependencies based on selected options and initialize a Git repository.",
            "dependencies": [
              3
            ],
            "details": "1. Create a function to generate the appropriate package.json based on selected options\n2. Implement the dependency installation logic using execa\n3. Add support for different package managers (npm, yarn, pnpm)\n4. Implement Git repository initialization\n5. Create a .gitignore file with appropriate entries\n6. Add initial commit with project setup\n7. Handle errors during installation process",
            "status": "pending",
            "testStrategy": "Test installation with different package managers and verify Git initialization"
          },
          {
            "id": 5,
            "title": "Add error handling, validation, and post-installation instructions",
            "description": "Implement comprehensive error handling, input validation, and helpful post-installation instructions for users.",
            "dependencies": [
              4
            ],
            "details": "1. Add try/catch blocks around critical operations\n2. Implement input validation for project name and path\n3. Add checks for existing directories and conflicts\n4. Create helpful error messages with suggested fixes\n5. Implement colorful console output for better UX\n6. Add post-installation instructions with next steps\n7. Create a function to detect and suggest available commands based on the generated project",
            "status": "pending",
            "testStrategy": "Test error scenarios like invalid project names, existing directories, and failed installations"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Auth Feature Module",
        "description": "Develop the auth feature module that integrates different authentication providers (Clerk, NextAuth.js, Supabase) into a project.",
        "details": "1. Create the auth feature module in the CLI package:\n   ```typescript\n   // src/features/auth.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { execa } from 'execa';\n   import { renderTemplate, writeFile, updatePackageJson } from '@oneship/core';\n   \n   export async function addAuth(provider: string): Promise<void> {\n     console.log(`Adding ${provider} authentication...`);\n     \n     // Validate provider\n     const validProviders = ['clerk', 'next-auth', 'supabase'];\n     if (!validProviders.includes(provider)) {\n       throw new Error(`Invalid auth provider: ${provider}. Valid options are: ${validProviders.join(', ')}`);\n     }\n     \n     // Get template directory\n     const templateDir = path.resolve(__dirname, `../../templates/auth/${provider}`);\n     \n     // Install dependencies based on provider\n     const dependencies = {\n       'clerk': ['@clerk/nextjs'],\n       'next-auth': ['next-auth'],\n       'supabase': ['@supabase/auth-helpers-nextjs', '@supabase/supabase-js']\n     };\n     \n     await execa('pnpm', ['add', ...dependencies[provider]], { stdio: 'inherit' });\n     \n     // Copy template files\n     const projectDir = process.cwd();\n     await fs.copy(templateDir, projectDir, { overwrite: false });\n     \n     // Update .env file with required variables\n     const envVars = {\n       'clerk': ['NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY', 'CLERK_SECRET_KEY'],\n       'next-auth': ['NEXTAUTH_SECRET', 'NEXTAUTH_URL'],\n       'supabase': ['NEXT_PUBLIC_SUPABASE_URL', 'NEXT_PUBLIC_SUPABASE_ANON_KEY']\n     };\n     \n     const envPath = path.join(projectDir, '.env');\n     let envContent = await fs.readFile(envPath, 'utf-8').catch(() => '');\n     \n     for (const envVar of envVars[provider]) {\n       if (!envContent.includes(envVar)) {\n         envContent += `\\n${envVar}=your-${envVar.toLowerCase()}-here`;\n       }\n     }\n     \n     await writeFile(envPath, envContent);\n     \n     // Update next.config.js for Clerk if needed\n     if (provider === 'clerk') {\n       const nextConfigPath = path.join(projectDir, 'next.config.js');\n       let nextConfig = await fs.readFile(nextConfigPath, 'utf-8');\n       \n       if (!nextConfig.includes('clerk')) {\n         nextConfig = nextConfig.replace(\n           'const nextConfig = {',\n           'const nextConfig = {\\n  experimental: {\\n    serverActions: true,\\n  },'\n         );\n       }\n       \n       await writeFile(nextConfigPath, nextConfig);\n     }\n     \n     console.log(`✅ Added ${provider} authentication`);\n     console.log(`Don't forget to update your .env file with the required variables!`);\n   }\n   ```\n2. Create templates for each auth provider in the templates package\n3. Implement Clerk authentication template with middleware, sign-in/sign-up pages, and user context\n4. Implement NextAuth.js template with API routes, providers configuration, and session handling\n5. Implement Supabase Auth template with client initialization, auth helpers, and protected routes\n6. Add documentation for each auth provider in the generated code\n7. Implement error handling and validation",
        "testStrategy": "Test the auth feature module with each provider option. Verify the correct dependencies are installed and template files are copied. Test the .env file updates with different existing configurations. Ensure the generated authentication code works correctly by creating a test project and verifying authentication flows.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Database Feature Module",
        "description": "Develop the database feature module that integrates different database providers (Prisma, Drizzle, Supabase) into a project.",
        "details": "1. Create the database feature module in the CLI package:\n   ```typescript\n   // src/features/database.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { execa } from 'execa';\n   import { renderTemplate, writeFile, updatePackageJson } from '@oneship/core';\n   \n   export async function addDatabase(provider: string, database: string = 'postgres'): Promise<void> {\n     console.log(`Adding ${provider} with ${database} database...`);\n     \n     // Validate provider\n     const validProviders = ['prisma', 'drizzle', 'supabase'];\n     if (!validProviders.includes(provider)) {\n       throw new Error(`Invalid database provider: ${provider}. Valid options are: ${validProviders.join(', ')}`);\n     }\n     \n     // Validate database type\n     const validDatabases = ['postgres', 'mysql', 'sqlite', 'mongodb'];\n     if (!validDatabases.includes(database)) {\n       throw new Error(`Invalid database type: ${database}. Valid options are: ${validDatabases.join(', ')}`);\n     }\n     \n     // Get template directory\n     const templateDir = path.resolve(__dirname, `../../templates/db/${provider}`);\n     \n     // Install dependencies based on provider\n     const dependencies = {\n       'prisma': ['@prisma/client'],\n       'drizzle': ['drizzle-orm', database === 'postgres' ? 'postgres' : database === 'mysql' ? 'mysql2' : 'better-sqlite3'],\n       'supabase': ['@supabase/supabase-js']\n     };\n     \n     const devDependencies = {\n       'prisma': ['prisma'],\n       'drizzle': ['drizzle-kit'],\n       'supabase': []\n     };\n     \n     await execa('pnpm', ['add', ...dependencies[provider]], { stdio: 'inherit' });\n     if (devDependencies[provider].length > 0) {\n       await execa('pnpm', ['add', '-D', ...devDependencies[provider]], { stdio: 'inherit' });\n     }\n     \n     // Copy template files\n     const projectDir = process.cwd();\n     await fs.copy(templateDir, projectDir, { overwrite: false });\n     \n     // Customize templates based on database type\n     if (provider === 'prisma') {\n       // Create prisma/schema.prisma with selected database\n       const schemaPath = path.join(projectDir, 'prisma', 'schema.prisma');\n       const schemaTemplate = await fs.readFile(path.join(templateDir, 'schema.prisma.template'), 'utf-8');\n       const schema = schemaTemplate.replace('{{DATABASE_PROVIDER}}', database);\n       await writeFile(schemaPath, schema);\n       \n       // Initialize Prisma\n       await execa('npx', ['prisma', 'init'], { stdio: 'inherit', cwd: projectDir });\n     }\n     \n     if (provider === 'drizzle') {\n       // Create drizzle schema with selected database\n       const schemaDir = path.join(projectDir, 'db', 'schema');\n       await fs.ensureDir(schemaDir);\n       \n       const schemaTemplate = await fs.readFile(path.join(templateDir, `schema.${database}.ts.template`), 'utf-8');\n       await writeFile(path.join(schemaDir, 'index.ts'), schemaTemplate);\n       \n       // Create drizzle config\n       const configTemplate = await fs.readFile(path.join(templateDir, 'drizzle.config.ts.template'), 'utf-8');\n       const config = configTemplate.replace('{{DATABASE_TYPE}}', database);\n       await writeFile(path.join(projectDir, 'drizzle.config.ts'), config);\n     }\n     \n     // Update .env file with required variables\n     const envVars = {\n       'prisma': ['DATABASE_URL'],\n       'drizzle': ['DATABASE_URL'],\n       'supabase': ['NEXT_PUBLIC_SUPABASE_URL', 'NEXT_PUBLIC_SUPABASE_ANON_KEY']\n     };\n     \n     const envPath = path.join(projectDir, '.env');\n     let envContent = await fs.readFile(envPath, 'utf-8').catch(() => '');\n     \n     for (const envVar of envVars[provider]) {\n       if (!envContent.includes(envVar)) {\n         envContent += `\\n${envVar}=your-${envVar.toLowerCase()}-here`;\n       }\n     }\n     \n     await writeFile(envPath, envContent);\n     \n     // Update package.json with scripts\n     if (provider === 'prisma') {\n       await updatePackageJson(path.join(projectDir, 'package.json'), {\n         scripts: {\n           'db:generate': 'prisma generate',\n           'db:push': 'prisma db push',\n           'db:studio': 'prisma studio'\n         }\n       });\n     }\n     \n     if (provider === 'drizzle') {\n       await updatePackageJson(path.join(projectDir, 'package.json'), {\n         scripts: {\n           'db:generate': 'drizzle-kit generate:${database}',\n           'db:push': 'drizzle-kit push:${database}',\n           'db:studio': 'drizzle-kit studio'\n         }\n       });\n     }\n     \n     console.log(`✅ Added ${provider} with ${database} database`);\n     console.log(`Don't forget to update your .env file with the required variables!`);\n   }\n   ```\n2. Create templates for each database provider in the templates package\n3. Implement Prisma template with schema, client initialization, and example models\n4. Implement Drizzle template with schema, client initialization, and example models\n5. Implement Supabase template with client initialization and example queries\n6. Add documentation for each database provider in the generated code\n7. Implement error handling and validation",
        "testStrategy": "Test the database feature module with each provider and database type combination. Verify the correct dependencies are installed and template files are copied. Test the .env file updates with different existing configurations. Ensure the generated database code works correctly by creating a test project and verifying database operations.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Environment Management Module",
        "description": "Develop the environment management module that handles .env file configuration and provides typed access to environment variables.",
        "details": "1. Create the environment management module in the CLI package:\n   ```typescript\n   // src/features/env.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { writeFile } from '@oneship/core';\n   \n   export async function addEnv(key: string, value: string): Promise<void> {\n     console.log(`Adding environment variable: ${key}`);\n     \n     // Validate key\n     if (!key) {\n       throw new Error('Environment variable key is required');\n     }\n     \n     const projectDir = process.cwd();\n     const envPath = path.join(projectDir, '.env');\n     let envContent = await fs.readFile(envPath, 'utf-8').catch(() => '');\n     \n     // Check if key already exists\n     const regex = new RegExp(`^${key}=.*`, 'm');\n     if (regex.test(envContent)) {\n       // Update existing key\n       envContent = envContent.replace(regex, `${key}=${value}`);\n     } else {\n       // Add new key\n       envContent += `\\n${key}=${value}`;\n     }\n     \n     await writeFile(envPath, envContent);\n     \n     // Update env.ts file with typed access\n     const envTypesPath = path.join(projectDir, 'env.ts');\n     let envTypesContent = await fs.readFile(envTypesPath, 'utf-8').catch(() => {\n       return `import { z } from 'zod';\\n\\nexport const envSchema = z.object({\\n  // Add your environment variables here\\n});\\n\\ndeclare global {\\n  namespace NodeJS {\\n    interface ProcessEnv extends z.infer<typeof envSchema> {}\\n  }\\n}\\n`;\n     });\n     \n     // Add key to envSchema if not already present\n     if (!envTypesContent.includes(`  ${key}:`)) {\n       envTypesContent = envTypesContent.replace(\n         'export const envSchema = z.object({',\n         `export const envSchema = z.object({\\n  ${key}: z.string(),`\n       );\n     }\n     \n     await writeFile(envTypesPath, envTypesContent);\n     \n     console.log(`✅ Added environment variable: ${key}`);\n   }\n   \n   export async function setupEnvValidation(): Promise<void> {\n     console.log('Setting up environment variable validation...');\n     \n     const projectDir = process.cwd();\n     \n     // Install zod if not already installed\n     const packageJsonPath = path.join(projectDir, 'package.json');\n     const packageJson = await fs.readJson(packageJsonPath);\n     \n     if (!packageJson.dependencies.zod) {\n       await execa('pnpm', ['add', 'zod'], { stdio: 'inherit' });\n     }\n     \n     // Create env.ts file\n     const envTypesPath = path.join(projectDir, 'env.ts');\n     const envTypesContent = `import { z } from 'zod';\\n\\nexport const envSchema = z.object({\\n  // Add your environment variables here\\n});\\n\\ndeclare global {\\n  namespace NodeJS {\\n    interface ProcessEnv extends z.infer<typeof envSchema> {}\\n  }\\n}\\n\\n// Validate environment variables at runtime\\nexport function validateEnv() {\\n  try {\\n    envSchema.parse(process.env);\\n  } catch (error) {\\n    console.error('❌ Invalid environment variables:', error.errors);\\n    throw new Error('Invalid environment variables');\\n  }\\n}\\n`;\n     \n     await writeFile(envTypesPath, envTypesContent);\n     \n     // Update next.config.js to validate env in development\n     const nextConfigPath = path.join(projectDir, 'next.config.js');\n     let nextConfig = await fs.readFile(nextConfigPath, 'utf-8');\n     \n     if (!nextConfig.includes('validateEnv')) {\n       nextConfig = nextConfig.replace(\n         'const nextConfig = {',\n         `const { validateEnv } = require('./env');\\n\\n// Validate environment variables in development\\nif (process.env.NODE_ENV === 'development') {\\n  validateEnv();\\n}\\n\\nconst nextConfig = {`\n       );\n     }\n     \n     await writeFile(nextConfigPath, nextConfig);\n     \n     console.log('✅ Set up environment variable validation');\n   }\n   ```\n2. Create templates for environment configuration in the templates package\n3. Implement typed environment variable access using Zod for validation\n4. Add support for different environment files (.env.development, .env.production, etc.)\n5. Implement environment variable validation at runtime\n6. Add documentation for environment variable usage in the generated code\n7. Implement error handling and validation",
        "testStrategy": "Test the environment management module with different key-value pairs. Verify the .env file is correctly updated with new and existing keys. Test the typed access generation with various environment variables. Ensure the validation works correctly by testing with valid and invalid environment configurations.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Custom Feature Scaffolding",
        "description": "Develop the feature scaffolding module that allows developers to create custom features with components, hooks, and API routes.",
        "details": "1. Create the feature scaffolding module in the CLI package:\n   ```typescript\n   // src/features/feature.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { renderTemplate, createDirectory, writeFile } from '@oneship/core';\n   \n   export async function addFeature(name: string): Promise<void> {\n     console.log(`Adding feature: ${name}`);\n     \n     // Validate feature name\n     if (!name) {\n       throw new Error('Feature name is required');\n     }\n     \n     // Convert to kebab-case for directory and pascal case for component names\n     const kebabName = name.toLowerCase().replace(/\\s+/g, '-');\n     const pascalName = name\n       .split(/[-\\s]+/)\n       .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n       .join('');\n     \n     const projectDir = process.cwd();\n     const featureDir = path.join(projectDir, 'features', kebabName);\n     \n     // Check if feature already exists\n     if (await fs.pathExists(featureDir)) {\n       throw new Error(`Feature ${name} already exists`);\n     }\n     \n     // Create feature directory structure\n     await createDirectory(featureDir);\n     await createDirectory(path.join(featureDir, 'components'));\n     await createDirectory(path.join(featureDir, 'hooks'));\n     await createDirectory(path.join(featureDir, 'api'));\n     await createDirectory(path.join(featureDir, 'utils'));\n     \n     // Create index.ts file\n     const indexContent = `// Export all components and hooks from the ${name} feature\\nexport * from './components';\\nexport * from './hooks';\\n`;\n     await writeFile(path.join(featureDir, 'index.ts'), indexContent);\n     \n     // Create components index.ts file\n     const componentsIndexContent = `// Export all components from the ${name} feature\\nexport * from './${pascalName}';\\n`;\n     await writeFile(path.join(featureDir, 'components', 'index.ts'), componentsIndexContent);\n     \n     // Create main component file\n     const componentContent = `import React from 'react';\\n\\ninterface ${pascalName}Props {\\n  // Add props here\\n}\\n\\nexport const ${pascalName}: React.FC<${pascalName}Props> = (props) => {\\n  return (\\n    <div className=\"${kebabName}-container\">\\n      <h2>${name}</h2>\\n      {/* Add your component content here */}\\n    </div>\\n  );\\n};\\n`;\n     await writeFile(path.join(featureDir, 'components', `${pascalName}.tsx`), componentContent);\n     \n     // Create hooks index.ts file\n     const hooksIndexContent = `// Export all hooks from the ${name} feature\\nexport * from './use${pascalName}';\\n`;\n     await writeFile(path.join(featureDir, 'hooks', 'index.ts'), hooksIndexContent);\n     \n     // Create main hook file\n     const hookContent = `import { useState, useEffect } from 'react';\\n\\nexport function use${pascalName}() {\\n  const [data, setData] = useState(null);\\n  const [loading, setLoading] = useState(false);\\n  const [error, setError] = useState(null);\\n\\n  useEffect(() => {\\n    // Add your hook logic here\\n  }, []);\\n\\n  return { data, loading, error };\\n}\\n`;\n     await writeFile(path.join(featureDir, 'hooks', `use${pascalName}.ts`), hookContent);\n     \n     // Create API route if using app router\n     const appApiDir = path.join(projectDir, 'app', 'api', kebabName);\n     if (await fs.pathExists(path.join(projectDir, 'app'))) {\n       await createDirectory(appApiDir);\n       \n       const apiRouteContent = `import { NextRequest, NextResponse } from 'next/server';\\n\\nexport async function GET(request: NextRequest) {\\n  try {\\n    // Add your API logic here\\n    return NextResponse.json({ message: '${pascalName} API' });\\n  } catch (error) {\\n    return NextResponse.json({ error: error.message }, { status: 500 });\\n  }\\n}\\n\\nexport async function POST(request: NextRequest) {\\n  try {\\n    const body = await request.json();\\n    // Add your API logic here\\n    return NextResponse.json({ message: '${pascalName} created' });\\n  } catch (error) {\\n    return NextResponse.json({ error: error.message }, { status: 500 });\\n  }\\n}\\n`;\n       await writeFile(path.join(appApiDir, 'route.ts'), apiRouteContent);\n     }\n     \n     // Create utils file\n     const utilsContent = `// Utility functions for the ${name} feature\\n\\nexport function format${pascalName}Data(data: any) {\\n  // Add your utility logic here\\n  return data;\\n}\\n`;\n     await writeFile(path.join(featureDir, 'utils', 'index.ts'), utilsContent);\n     \n     console.log(`✅ Added feature: ${name}`);\n     console.log(`Feature directory: ${featureDir}`);\n     console.log(`Import the feature components with: import { ${pascalName} } from '@/features/${kebabName}';`);\n   }\n   ```\n2. Create templates for feature scaffolding in the templates package\n3. Implement support for different feature types (page, component, API, etc.)\n4. Add support for generating test files for components and hooks\n5. Implement support for generating documentation for features\n6. Add support for generating TypeScript interfaces and types\n7. Implement error handling and validation",
        "testStrategy": "Test the feature scaffolding module with different feature names and types. Verify the correct directory structure and files are created. Test the generated code for syntax errors and TypeScript compatibility. Ensure the feature can be imported and used in a Next.js application.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Plugin System",
        "description": "Develop the plugin system that allows developers to extend the CLI with custom commands and templates.",
        "details": "1. Create the plugin system module in the CLI package:\n   ```typescript\n   // src/plugins/index.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { Command } from 'commander';\n   \n   export interface Plugin {\n     name: string;\n     description: string;\n     commands?: PluginCommand[];\n     templates?: PluginTemplate[];\n   }\n   \n   export interface PluginCommand {\n     name: string;\n     description: string;\n     action: (options: any) => Promise<void>;\n     options?: PluginCommandOption[];\n   }\n   \n   export interface PluginCommandOption {\n     flags: string;\n     description: string;\n     defaultValue?: any;\n   }\n   \n   export interface PluginTemplate {\n     name: string;\n     path: string;\n   }\n   \n   export async function loadPlugins(program: Command): Promise<Plugin[]> {\n     const projectDir = process.cwd();\n     const pluginsDir = path.join(projectDir, '.oneship');\n     \n     if (!await fs.pathExists(pluginsDir)) {\n       return [];\n     }\n     \n     const pluginFiles = await fs.readdir(pluginsDir);\n     const plugins: Plugin[] = [];\n     \n     for (const file of pluginFiles) {\n       if (file.endsWith('.js') || file.endsWith('.ts')) {\n         try {\n           const pluginPath = path.join(pluginsDir, file);\n           const plugin = require(pluginPath).default as Plugin;\n           \n           if (!plugin || !plugin.name) {\n             console.warn(`Invalid plugin in ${file}: missing name property`);\n             continue;\n           }\n           \n           // Register plugin commands\n           if (plugin.commands) {\n             for (const command of plugin.commands) {\n               const cmd = program.command(command.name).description(command.description);\n               \n               // Add command options\n               if (command.options) {\n                 for (const option of command.options) {\n                   cmd.option(option.flags, option.description, option.defaultValue);\n                 }\n               }\n               \n               // Set command action\n               cmd.action(command.action);\n             }\n           }\n           \n           plugins.push(plugin);\n           console.log(`Loaded plugin: ${plugin.name}`);\n         } catch (error) {\n           console.error(`Error loading plugin from ${file}:`, error);\n         }\n       }\n     }\n     \n     return plugins;\n   }\n   \n   export async function createPlugin(name: string): Promise<void> {\n     console.log(`Creating plugin: ${name}`);\n     \n     // Validate plugin name\n     if (!name) {\n       throw new Error('Plugin name is required');\n     }\n     \n     const projectDir = process.cwd();\n     const pluginsDir = path.join(projectDir, '.oneship');\n     await fs.ensureDir(pluginsDir);\n     \n     const pluginPath = path.join(pluginsDir, `${name}.ts`);\n     \n     // Check if plugin already exists\n     if (await fs.pathExists(pluginPath)) {\n       throw new Error(`Plugin ${name} already exists`);\n     }\n     \n     // Create plugin template\n     const pluginTemplate = `import { Plugin } from 'oneship';\n\nconst ${name}Plugin: Plugin = {\n  name: '${name}',\n  description: '${name} plugin for OneShip',\n  commands: [\n    {\n      name: '${name}',\n      description: 'Run ${name} command',\n      options: [\n        {\n          flags: '--option <value>',\n          description: 'An example option',\n          defaultValue: 'default'\n        }\n      ],\n      action: async (options) => {\n        console.log('Running ${name} command with options:', options);\n        // Add your command logic here\n      }\n    }\n  ],\n  templates: [\n    {\n      name: '${name}',\n      path: './templates/${name}'\n    }\n  ]\n};\n\nexport default ${name}Plugin;\n`;\n     \n     await fs.writeFile(pluginPath, pluginTemplate);\n     \n     // Create templates directory for the plugin\n     const templatesDir = path.join(pluginsDir, 'templates', name);\n     await fs.ensureDir(templatesDir);\n     \n     // Create example template file\n     const exampleTemplatePath = path.join(templatesDir, 'example.ts');\n     const exampleTemplate = `// Example template for ${name} plugin\nexport const exampleComponent = \\`\nimport React from 'react';\n\nexport const Example = () => {\n  return (\n    <div>\n      <h1>${name} Example</h1>\n    </div>\n  );\n};\n\\`;\n`;\n     \n     await fs.writeFile(exampleTemplatePath, exampleTemplate);\n     \n     console.log(`✅ Created plugin: ${name}`);\n     console.log(`Plugin file: ${pluginPath}`);\n     console.log(`Templates directory: ${templatesDir}`);\n   }\n   ```\n2. Update the main CLI entry point to load plugins:\n   ```typescript\n   // src/index.ts\n   import { loadPlugins } from './plugins';\n   \n   // After registering built-in commands\n   loadPlugins(program).catch(error => {\n     console.error('Error loading plugins:', error);\n   });\n   ```\n3. Create a command to create new plugins:\n   ```typescript\n   // src/commands/plugin.ts\n   import { Command } from 'commander';\n   import { createPlugin } from '../plugins';\n   \n   export function registerPluginCommand(program: Command): void {\n     const plugin = program.command('plugin');\n     \n     plugin.command('create')\n       .description('Create a new plugin')\n       .argument('<name>', 'Plugin name')\n       .action(async (name) => {\n         await createPlugin(name);\n       });\n   }\n   ```\n4. Implement plugin discovery and loading mechanism\n5. Add support for plugin templates and commands\n6. Implement plugin validation and error handling\n7. Add documentation for creating and using plugins",
        "testStrategy": "Test the plugin system by creating and loading custom plugins. Verify that plugin commands are correctly registered and executed. Test plugin templates by generating code from them. Ensure error handling works correctly for invalid plugins. Test the plugin creation command with different plugin names.",
        "priority": "low",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Refactor create-oneship-app into CLI and Core Packages",
        "description": "Refactor the existing packages/create-oneship-app into separate packages/cli and packages/core to improve modularity and maintainability of the codebase.",
        "details": "1. Analyze the current structure of packages/create-oneship-app:\n   ```bash\n   # Examine the current structure\n   ls -la packages/create-oneship-app\n   ```\n\n2. Create the new package structure if not already present:\n   ```bash\n   mkdir -p packages/cli packages/core\n   ```\n\n3. Move CLI-specific functionality to packages/cli:\n   - Command-line interface code\n   - Command handlers\n   - User interaction logic\n   - CLI entry points\n   - CLI-specific utilities\n\n4. Move core functionality to packages/core:\n   - Shared utilities\n   - Template rendering logic\n   - File system operations\n   - Package management utilities\n   - Configuration handling\n\n5. Update package.json files for both packages:\n   - Set appropriate dependencies\n   - Configure build scripts\n   - Set up TypeScript configuration\n   - Define entry points\n\n6. Update import statements across the codebase:\n   ```typescript\n   // Before\n   import { someFunction } from '../utils';\n   \n   // After\n   import { someFunction } from '@oneship/core';\n   ```\n\n7. Set up proper exports in both packages:\n   ```typescript\n   // packages/core/src/index.ts\n   export * from './fs';\n   export * from './template';\n   export * from './package';\n   // etc.\n   \n   // packages/cli/src/index.ts\n   #!/usr/bin/env node\n   import { Command } from 'commander';\n   // CLI implementation\n   ```\n\n8. Update build configuration:\n   - Ensure TypeScript configs are properly set up\n   - Configure proper build output directories\n   - Set up proper module resolution\n\n9. Implement proper cross-package dependencies:\n   ```json\n   // packages/cli/package.json\n   {\n     \"dependencies\": {\n       \"@oneship/core\": \"workspace:*\",\n       \"commander\": \"^x.x.x\",\n       // other dependencies\n     }\n   }\n   ```\n\n10. Remove the original packages/create-oneship-app once the refactoring is complete and verified.",
        "testStrategy": "1. Verify package structure:\n   - Ensure all necessary files have been moved to the appropriate packages\n   - Check that no critical functionality has been lost\n\n2. Test package builds:\n   ```bash\n   cd packages/core\n   pnpm build\n   cd ../cli\n   pnpm build\n   ```\n\n3. Test CLI functionality:\n   ```bash\n   # Create a test project using the refactored CLI\n   node packages/cli/dist/index.js create my-test-app\n   ```\n\n4. Run unit tests for both packages:\n   ```bash\n   cd packages/core\n   pnpm test\n   cd ../cli\n   pnpm test\n   ```\n\n5. Verify cross-package imports work correctly:\n   - Check that CLI can properly import and use core functionality\n   - Ensure no circular dependencies exist\n\n6. Test all CLI commands to ensure they still work as expected:\n   - Test project creation\n   - Test adding features\n   - Test other commands\n\n7. Perform integration tests:\n   - Create a new project\n   - Add authentication\n   - Add database\n   - Verify the generated project builds and runs correctly\n\n8. Check for regressions by comparing the output of the original create-oneship-app with the refactored CLI for the same commands.",
        "status": "pending",
        "dependencies": [
          2,
          3
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-15T19:14:07.600Z",
      "updated": "2025-06-27T23:59:49.870Z",
      "description": "Tasks for master context"
    }
  }
}