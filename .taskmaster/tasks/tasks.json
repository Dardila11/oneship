{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Monorepo Structure",
        "description": "Initialize the monorepo structure with Turborepo for the OneShip project, including the core packages: create-oneship-app, cli, core, and templates.",
        "details": "1. Initialize a new repository with Git\n2. Set up Turborepo using pnpm:\n   ```bash\n   pnpm init\n   pnpm add -D turbo typescript @types/node\n   ```\n3. Create the monorepo structure:\n   ```\n   oneship/\n   ├── packages/\n   │   ├── create-oneship-app/     # CLI to scaffold new projects\n   │   ├── cli/                    # Main CLI (e.g., `oneship add auth`)\n   │   ├── core/                   # Shared utilities and helpers\n   │   └── templates/              # Source for generating project and features\n   ├── examples/                   # Sample apps\n   ├── docs/                       # Documentation\n   ├── package.json\n   ├── turbo.json\n   └── README.md\n   ```\n4. Configure turbo.json with appropriate pipelines for build, test, and lint\n5. Set up shared TypeScript configuration\n6. Configure package.json with appropriate scripts and workspaces",
        "testStrategy": "Verify the monorepo structure is correctly set up by running `pnpm install` and ensuring all packages can be built with `pnpm build`. Test workspace dependencies by importing a module from one package into another.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Git Repository and Base Project Structure",
            "description": "Set up the initial Git repository and create the base folder structure for the monorepo.",
            "dependencies": [],
            "details": "1. Create a new directory for the project\n2. Initialize Git repository with `git init`\n3. Create the initial folder structure including packages/, examples/, and docs/ directories\n4. Create a basic README.md with project overview\n5. Add .gitignore file with appropriate patterns for Node.js projects\n6. Make initial commit",
            "status": "done",
            "testStrategy": "Verify the directory structure is created correctly and Git repository is properly initialized."
          },
          {
            "id": 2,
            "title": "Configure Package Manager and Turborepo",
            "description": "Set up pnpm as the package manager and initialize Turborepo for monorepo management.",
            "dependencies": [
              1
            ],
            "details": "1. Initialize package.json with `pnpm init`\n2. Install Turborepo and TypeScript dependencies: `pnpm add -D turbo typescript @types/node`\n3. Configure pnpm workspaces in package.json\n4. Create turbo.json with initial pipeline configuration for build, test, and lint\n5. Set up shared tsconfig.json with base TypeScript configuration\n6. Configure root package.json scripts for common operations",
            "status": "done",
            "testStrategy": "Run `pnpm install` to verify workspace configuration is correct and dependencies install properly."
          },
          {
            "id": 3,
            "title": "Create Core and CLI Package Structures",
            "description": "Set up the core and CLI packages with their initial configurations.",
            "dependencies": [
              2
            ],
            "details": "1. Create packages/core/ directory with its own package.json\n2. Set up TypeScript configuration for the core package\n3. Create packages/cli/ directory with its own package.json\n4. Configure the CLI package with necessary dependencies\n5. Create basic entry points for both packages\n6. Set up package.json scripts for both packages that integrate with Turborepo pipelines",
            "status": "done",
            "testStrategy": "Verify that both packages can be built using the Turborepo pipeline and have correct dependencies."
          },
          {
            "id": 4,
            "title": "Implement Create-OneShip-App Package",
            "description": "Create the scaffolding package that will be used to initialize new OneShip projects.",
            "dependencies": [
              3
            ],
            "details": "1. Create packages/create-oneship-app/ directory with its own package.json\n2. Configure package.json with bin entry for CLI execution\n3. Set up TypeScript configuration\n4. Create basic CLI structure with commander or similar\n5. Implement skeleton for project initialization logic\n6. Configure build process to produce executable package",
            "status": "done",
            "testStrategy": "Test the package locally by linking it (`pnpm link`) and verifying it can be executed as a command-line tool."
          },
          {
            "id": 5,
            "title": "Set Up Templates Package and Integration",
            "description": "Create the templates package and integrate it with the create-oneship-app tool.",
            "dependencies": [
              4
            ],
            "details": "1. Create packages/templates/ directory with its own package.json\n2. Create initial template structure for basic project\n3. Set up file organization for different template types\n4. Implement template loading mechanism in core package\n5. Connect create-oneship-app to use templates package\n6. Add documentation for template structure and usage",
            "status": "done",
            "testStrategy": "Test the integration by using create-oneship-app to generate a project from a template and verify the output matches expectations."
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Core Package",
        "description": "Develop the core package with shared utilities and helpers that will be used across the CLI and template generation.",
        "details": "1. Initialize the core package with TypeScript:\n   ```bash\n   cd packages/core\n   pnpm init\n   pnpm add -D typescript @types/node\n   ```\n2. Implement file system utilities:\n   ```typescript\n   // src/fs.ts\n   import fs from 'fs-extra';\n   \n   export const createDirectory = async (path: string): Promise<void> => {\n     await fs.ensureDir(path);\n   };\n   \n   export const writeFile = async (path: string, content: string): Promise<void> => {\n     await fs.outputFile(path, content);\n   };\n   ```\n3. Implement template rendering utilities using a templating engine like EJS:\n   ```typescript\n   // src/template.ts\n   import ejs from 'ejs';\n   \n   export const renderTemplate = (template: string, data: Record<string, any>): string => {\n     return ejs.render(template, data);\n   };\n   ```\n4. Create package management utilities:\n   ```typescript\n   // src/package.ts\n   import { execa } from 'execa';\n   import fs from 'fs-extra';\n   \n   export const installDependencies = async (dependencies: string[], dev = false): Promise<void> => {\n     const args = ['add', ...(dev ? ['-D'] : []), ...dependencies];\n     await execa('pnpm', args, { stdio: 'inherit' });\n   };\n   \n   export const updatePackageJson = async (path: string, updates: Record<string, any>): Promise<void> => {\n     const pkg = await fs.readJson(path);\n     const updatedPkg = { ...pkg, ...updates };\n     await fs.writeJson(path, updatedPkg, { spaces: 2 });\n   };\n   ```\n5. Implement logging utilities with colors and formatting\n6. Create configuration management utilities for .env files\n7. Export all utilities from an index.ts file",
        "testStrategy": "Write unit tests for each utility function using Jest or Vitest. Test file operations with mock file systems. Test template rendering with various inputs and expected outputs. Test package management utilities by mocking execa calls.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement logging utilities",
            "description": "Create a logging module with colored output and formatting options",
            "dependencies": [],
            "details": "Implement a Logger class with methods for different log levels (info, warn, error, debug). Use a library like chalk for colored output. Include options for log formatting and timestamp inclusion.",
            "status": "done",
            "testStrategy": "Write unit tests for each log level and formatting option"
          },
          {
            "id": 2,
            "title": "Create configuration management utilities",
            "description": "Develop utilities for managing .env files and configuration settings",
            "dependencies": [],
            "details": "Implement functions to read from .env files, parse environment variables, and provide a centralized configuration object. Include support for different environments (development, production, etc.).",
            "status": "in-progress",
            "testStrategy": "Create test .env files and verify correct parsing and configuration loading"
          },
          {
            "id": 3,
            "title": "Implement error handling utilities",
            "description": "Create a set of custom error classes and error handling functions",
            "dependencies": [
              1
            ],
            "details": "Define custom error classes for different types of errors (e.g., ValidationError, NetworkError). Implement a global error handler that logs errors using the logging utilities and provides appropriate error responses.",
            "status": "pending",
            "testStrategy": "Test error throwing and handling for various scenarios, including integration with the logging utilities"
          },
          {
            "id": 4,
            "title": "Develop utility functions for string manipulation",
            "description": "Create a set of helper functions for common string operations",
            "dependencies": [],
            "details": "Implement functions for camelCase, snake_case, and kebab-case conversions, string truncation, pluralization, and other common string manipulations that may be useful across the project.",
            "status": "pending",
            "testStrategy": "Write unit tests for each string manipulation function with various input scenarios"
          },
          {
            "id": 5,
            "title": "Create an index.ts file to export all utilities",
            "description": "Consolidate all utility exports into a single index.ts file for easy importing",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create an index.ts file that imports and re-exports all utility functions and classes from the various modules (fs, template, package, logging, configuration, error handling, string manipulation). Ensure proper TypeScript typing for all exports.",
            "status": "pending",
            "testStrategy": "Verify that all utilities can be imported correctly from the index file in a test script"
          }
        ]
      },
      {
        "id": 3,
        "title": "Develop CLI Package",
        "description": "Create the main CLI package that will handle commands like 'add auth', 'add db', etc. using Commander.js for command routing.",
        "details": "1. Initialize the CLI package:\n   ```bash\n   cd packages/cli\n   pnpm init\n   pnpm add commander prompts fs-extra execa\n   pnpm add -D typescript @types/node @types/fs-extra\n   ```\n2. Create the main CLI entry point:\n   ```typescript\n   // src/index.ts\n   #!/usr/bin/env node\n   import { Command } from 'commander';\n   import { version } from '../package.json';\n   \n   const program = new Command();\n   \n   program\n     .name('oneship')\n     .description('CLI toolkit for building and deploying modern web apps')\n     .version(version);\n   \n   // Import and register commands\n   import { registerAddCommand } from './commands/add';\n   \n   registerAddCommand(program);\n   \n   program.parse(process.argv);\n   ```\n3. Implement the 'add' command with subcommands for auth, db, env, and feature:\n   ```typescript\n   // src/commands/add.ts\n   import { Command } from 'commander';\n   import prompts from 'prompts';\n   import { addAuth } from '../features/auth';\n   import { addDatabase } from '../features/database';\n   import { addEnv } from '../features/env';\n   import { addFeature } from '../features/feature';\n   \n   export function registerAddCommand(program: Command): void {\n     const add = program.command('add');\n     \n     add.command('auth')\n       .description('Add authentication to your project')\n       .option('--using <provider>', 'Auth provider (clerk, next-auth, supabase)')\n       .action(async (options) => {\n         // If provider not specified, prompt user\n         if (!options.using) {\n           const response = await prompts({\n             type: 'select',\n             name: 'provider',\n             message: 'Select an auth provider:',\n             choices: [\n               { title: 'Clerk', value: 'clerk' },\n               { title: 'NextAuth.js', value: 'next-auth' },\n               { title: 'Supabase Auth', value: 'supabase' }\n             ]\n           });\n           options.using = response.provider;\n         }\n         \n         await addAuth(options.using);\n       });\n     \n     // Similar implementations for db, env, and feature commands\n   }\n   ```\n4. Implement feature modules for auth, database, env, and custom features\n5. Create utility functions for detecting project type and structure\n6. Set up bin entry in package.json for CLI execution\n7. Implement error handling and validation for commands",
        "testStrategy": "Test the CLI commands using mock file systems and spying on execa calls. Write integration tests that verify the correct templates are selected and files are generated. Test the interactive prompts by mocking user input. Verify error handling by testing with invalid inputs and configurations.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Create Template Package",
        "description": "Develop the templates package containing source files for generating projects and features, including auth integrations, database setups, and feature scaffolding.",
        "details": "1. Initialize the templates package:\n   ```bash\n   cd packages/templates\n   pnpm init\n   ```\n2. Create folder structure for different templates:\n   ```\n   templates/\n   ├── project/              # Base project templates\n   │   ├── next-app/        # Next.js app router template\n   │   └── next-pages/      # Next.js pages router template\n   ├── auth/                # Auth integration templates\n   │   ├── clerk/\n   │   ├── next-auth/\n   │   └── supabase/\n   ├── db/                  # Database integration templates\n   │   ├── prisma/\n   │   ├── drizzle/\n   │   └── supabase/\n   ├── features/            # Feature templates\n   │   ├── dashboard/\n   │   └── profile/\n   └── env/                 # Environment configuration templates\n   ```\n3. Create base Next.js app template with the following structure:\n   ```\n   next-app/\n   ├── app/\n   │   ├── layout.tsx\n   │   └── page.tsx\n   ├── features/\n   │   └── core/\n   │       ├── layout/\n   │       ├── components/\n   │       └── hooks/\n   ├── public/\n   ├── styles/\n   ├── .env.example\n   ├── next.config.js\n   ├── package.json\n   ├── tailwind.config.ts\n   ├── tsconfig.json\n   └── README.md\n   ```\n4. Implement auth templates for different providers (Clerk, NextAuth.js, Supabase)\n5. Create database templates for Prisma, Drizzle, and Supabase\n6. Develop feature templates for common features like dashboard, profile, etc.\n7. Implement environment configuration templates\n8. Use EJS or similar templating for dynamic content",
        "testStrategy": "Verify template files are correctly structured and contain valid syntax. Test template rendering with different variables and configurations. Ensure generated files are valid TypeScript/JavaScript and can be compiled. Test integration with the CLI package to ensure templates are correctly applied.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement create-oneship-app Package",
        "description": "Develop the create-oneship-app package that scaffolds new projects with interactive prompts for configuration options.",
        "details": "1. Initialize the create-oneship-app package:\n   ```bash\n   cd packages/create-oneship-app\n   pnpm init\n   pnpm add commander prompts fs-extra execa\n   pnpm add -D typescript @types/node @types/fs-extra\n   ```\n2. Create the main entry point:\n   ```typescript\n   // src/index.ts\n   #!/usr/bin/env node\n   import { Command } from 'commander';\n   import prompts from 'prompts';\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { execa } from 'execa';\n   import { renderTemplate, createDirectory } from '@oneship/core';\n   \n   const program = new Command();\n   \n   program\n     .name('create-oneship-app')\n     .description('Create a new OneShip app')\n     .argument('[name]', 'Project name')\n     .action(async (name) => {\n       // If name not provided, prompt for it\n       if (!name) {\n         const response = await prompts({\n           type: 'text',\n           name: 'name',\n           message: 'What is your project named?',\n           initial: 'my-oneship-app'\n         });\n         name = response.name;\n       }\n       \n       // Prompt for configuration options\n       const options = await prompts([\n         {\n           type: 'select',\n           name: 'language',\n           message: 'JavaScript or TypeScript?',\n           choices: [\n             { title: 'TypeScript', value: 'typescript' },\n             { title: 'JavaScript', value: 'javascript' }\n           ],\n           initial: 0\n         },\n         {\n           type: 'confirm',\n           name: 'tailwind',\n           message: 'Use TailwindCSS?',\n           initial: true\n         },\n         {\n           type: 'confirm',\n           name: 'shadcn',\n           message: 'Add Shadcn UI?',\n           initial: false\n         },\n         {\n           type: 'confirm',\n           name: 'auth',\n           message: 'Include Auth?',\n           initial: false\n         },\n         {\n           type: 'select',\n           name: 'authProvider',\n           message: 'Select auth provider:',\n           choices: [\n             { title: 'Clerk', value: 'clerk' },\n             { title: 'NextAuth.js', value: 'next-auth' },\n             { title: 'Supabase Auth', value: 'supabase' }\n           ],\n           initial: 0,\n           skip: (prev, values) => !values.auth\n         }\n       ]);\n       \n       // Create project directory\n       const projectDir = path.resolve(process.cwd(), name);\n       await createDirectory(projectDir);\n       \n       // Copy base template\n       const templateDir = path.resolve(__dirname, '../templates/project/next-app');\n       await fs.copy(templateDir, projectDir);\n       \n       // Apply configuration options\n       // ...\n       \n       // Install dependencies\n       console.log('Installing dependencies...');\n       await execa('pnpm', ['install'], { cwd: projectDir, stdio: 'inherit' });\n       \n       console.log(`\\nSuccess! Created ${name} at ${projectDir}\\n`);\n       console.log('Next steps:');\n       console.log(`  cd ${name}`);\n       console.log('  pnpm dev');\n     });\n   \n   program.parse(process.argv);\n   ```\n3. Set up bin entry in package.json for CLI execution\n4. Implement template selection and rendering based on user choices\n5. Add support for installing dependencies and initializing Git repository\n6. Implement post-installation instructions and next steps\n7. Add error handling and validation",
        "testStrategy": "Test the CLI with different project names and configuration options. Verify the generated project structure matches the expected output. Test error handling by simulating file system errors and invalid inputs. Ensure the generated project can be built and run successfully.",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Auth Feature Module",
        "description": "Develop the auth feature module that integrates different authentication providers (Clerk, NextAuth.js, Supabase) into a project.",
        "details": "1. Create the auth feature module in the CLI package:\n   ```typescript\n   // src/features/auth.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { execa } from 'execa';\n   import { renderTemplate, writeFile, updatePackageJson } from '@oneship/core';\n   \n   export async function addAuth(provider: string): Promise<void> {\n     console.log(`Adding ${provider} authentication...`);\n     \n     // Validate provider\n     const validProviders = ['clerk', 'next-auth', 'supabase'];\n     if (!validProviders.includes(provider)) {\n       throw new Error(`Invalid auth provider: ${provider}. Valid options are: ${validProviders.join(', ')}`);\n     }\n     \n     // Get template directory\n     const templateDir = path.resolve(__dirname, `../../templates/auth/${provider}`);\n     \n     // Install dependencies based on provider\n     const dependencies = {\n       'clerk': ['@clerk/nextjs'],\n       'next-auth': ['next-auth'],\n       'supabase': ['@supabase/auth-helpers-nextjs', '@supabase/supabase-js']\n     };\n     \n     await execa('pnpm', ['add', ...dependencies[provider]], { stdio: 'inherit' });\n     \n     // Copy template files\n     const projectDir = process.cwd();\n     await fs.copy(templateDir, projectDir, { overwrite: false });\n     \n     // Update .env file with required variables\n     const envVars = {\n       'clerk': ['NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY', 'CLERK_SECRET_KEY'],\n       'next-auth': ['NEXTAUTH_SECRET', 'NEXTAUTH_URL'],\n       'supabase': ['NEXT_PUBLIC_SUPABASE_URL', 'NEXT_PUBLIC_SUPABASE_ANON_KEY']\n     };\n     \n     const envPath = path.join(projectDir, '.env');\n     let envContent = await fs.readFile(envPath, 'utf-8').catch(() => '');\n     \n     for (const envVar of envVars[provider]) {\n       if (!envContent.includes(envVar)) {\n         envContent += `\\n${envVar}=your-${envVar.toLowerCase()}-here`;\n       }\n     }\n     \n     await writeFile(envPath, envContent);\n     \n     // Update next.config.js for Clerk if needed\n     if (provider === 'clerk') {\n       const nextConfigPath = path.join(projectDir, 'next.config.js');\n       let nextConfig = await fs.readFile(nextConfigPath, 'utf-8');\n       \n       if (!nextConfig.includes('clerk')) {\n         nextConfig = nextConfig.replace(\n           'const nextConfig = {',\n           'const nextConfig = {\\n  experimental: {\\n    serverActions: true,\\n  },'\n         );\n       }\n       \n       await writeFile(nextConfigPath, nextConfig);\n     }\n     \n     console.log(`✅ Added ${provider} authentication`);\n     console.log(`Don't forget to update your .env file with the required variables!`);\n   }\n   ```\n2. Create templates for each auth provider in the templates package\n3. Implement Clerk authentication template with middleware, sign-in/sign-up pages, and user context\n4. Implement NextAuth.js template with API routes, providers configuration, and session handling\n5. Implement Supabase Auth template with client initialization, auth helpers, and protected routes\n6. Add documentation for each auth provider in the generated code\n7. Implement error handling and validation",
        "testStrategy": "Test the auth feature module with each provider option. Verify the correct dependencies are installed and template files are copied. Test the .env file updates with different existing configurations. Ensure the generated authentication code works correctly by creating a test project and verifying authentication flows.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Database Feature Module",
        "description": "Develop the database feature module that integrates different database providers (Prisma, Drizzle, Supabase) into a project.",
        "details": "1. Create the database feature module in the CLI package:\n   ```typescript\n   // src/features/database.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { execa } from 'execa';\n   import { renderTemplate, writeFile, updatePackageJson } from '@oneship/core';\n   \n   export async function addDatabase(provider: string, database: string = 'postgres'): Promise<void> {\n     console.log(`Adding ${provider} with ${database} database...`);\n     \n     // Validate provider\n     const validProviders = ['prisma', 'drizzle', 'supabase'];\n     if (!validProviders.includes(provider)) {\n       throw new Error(`Invalid database provider: ${provider}. Valid options are: ${validProviders.join(', ')}`);\n     }\n     \n     // Validate database type\n     const validDatabases = ['postgres', 'mysql', 'sqlite', 'mongodb'];\n     if (!validDatabases.includes(database)) {\n       throw new Error(`Invalid database type: ${database}. Valid options are: ${validDatabases.join(', ')}`);\n     }\n     \n     // Get template directory\n     const templateDir = path.resolve(__dirname, `../../templates/db/${provider}`);\n     \n     // Install dependencies based on provider\n     const dependencies = {\n       'prisma': ['@prisma/client'],\n       'drizzle': ['drizzle-orm', database === 'postgres' ? 'postgres' : database === 'mysql' ? 'mysql2' : 'better-sqlite3'],\n       'supabase': ['@supabase/supabase-js']\n     };\n     \n     const devDependencies = {\n       'prisma': ['prisma'],\n       'drizzle': ['drizzle-kit'],\n       'supabase': []\n     };\n     \n     await execa('pnpm', ['add', ...dependencies[provider]], { stdio: 'inherit' });\n     if (devDependencies[provider].length > 0) {\n       await execa('pnpm', ['add', '-D', ...devDependencies[provider]], { stdio: 'inherit' });\n     }\n     \n     // Copy template files\n     const projectDir = process.cwd();\n     await fs.copy(templateDir, projectDir, { overwrite: false });\n     \n     // Customize templates based on database type\n     if (provider === 'prisma') {\n       // Create prisma/schema.prisma with selected database\n       const schemaPath = path.join(projectDir, 'prisma', 'schema.prisma');\n       const schemaTemplate = await fs.readFile(path.join(templateDir, 'schema.prisma.template'), 'utf-8');\n       const schema = schemaTemplate.replace('{{DATABASE_PROVIDER}}', database);\n       await writeFile(schemaPath, schema);\n       \n       // Initialize Prisma\n       await execa('npx', ['prisma', 'init'], { stdio: 'inherit', cwd: projectDir });\n     }\n     \n     if (provider === 'drizzle') {\n       // Create drizzle schema with selected database\n       const schemaDir = path.join(projectDir, 'db', 'schema');\n       await fs.ensureDir(schemaDir);\n       \n       const schemaTemplate = await fs.readFile(path.join(templateDir, `schema.${database}.ts.template`), 'utf-8');\n       await writeFile(path.join(schemaDir, 'index.ts'), schemaTemplate);\n       \n       // Create drizzle config\n       const configTemplate = await fs.readFile(path.join(templateDir, 'drizzle.config.ts.template'), 'utf-8');\n       const config = configTemplate.replace('{{DATABASE_TYPE}}', database);\n       await writeFile(path.join(projectDir, 'drizzle.config.ts'), config);\n     }\n     \n     // Update .env file with required variables\n     const envVars = {\n       'prisma': ['DATABASE_URL'],\n       'drizzle': ['DATABASE_URL'],\n       'supabase': ['NEXT_PUBLIC_SUPABASE_URL', 'NEXT_PUBLIC_SUPABASE_ANON_KEY']\n     };\n     \n     const envPath = path.join(projectDir, '.env');\n     let envContent = await fs.readFile(envPath, 'utf-8').catch(() => '');\n     \n     for (const envVar of envVars[provider]) {\n       if (!envContent.includes(envVar)) {\n         envContent += `\\n${envVar}=your-${envVar.toLowerCase()}-here`;\n       }\n     }\n     \n     await writeFile(envPath, envContent);\n     \n     // Update package.json with scripts\n     if (provider === 'prisma') {\n       await updatePackageJson(path.join(projectDir, 'package.json'), {\n         scripts: {\n           'db:generate': 'prisma generate',\n           'db:push': 'prisma db push',\n           'db:studio': 'prisma studio'\n         }\n       });\n     }\n     \n     if (provider === 'drizzle') {\n       await updatePackageJson(path.join(projectDir, 'package.json'), {\n         scripts: {\n           'db:generate': 'drizzle-kit generate:${database}',\n           'db:push': 'drizzle-kit push:${database}',\n           'db:studio': 'drizzle-kit studio'\n         }\n       });\n     }\n     \n     console.log(`✅ Added ${provider} with ${database} database`);\n     console.log(`Don't forget to update your .env file with the required variables!`);\n   }\n   ```\n2. Create templates for each database provider in the templates package\n3. Implement Prisma template with schema, client initialization, and example models\n4. Implement Drizzle template with schema, client initialization, and example models\n5. Implement Supabase template with client initialization and example queries\n6. Add documentation for each database provider in the generated code\n7. Implement error handling and validation",
        "testStrategy": "Test the database feature module with each provider and database type combination. Verify the correct dependencies are installed and template files are copied. Test the .env file updates with different existing configurations. Ensure the generated database code works correctly by creating a test project and verifying database operations.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Environment Management Module",
        "description": "Develop the environment management module that handles .env file configuration and provides typed access to environment variables.",
        "details": "1. Create the environment management module in the CLI package:\n   ```typescript\n   // src/features/env.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { writeFile } from '@oneship/core';\n   \n   export async function addEnv(key: string, value: string): Promise<void> {\n     console.log(`Adding environment variable: ${key}`);\n     \n     // Validate key\n     if (!key) {\n       throw new Error('Environment variable key is required');\n     }\n     \n     const projectDir = process.cwd();\n     const envPath = path.join(projectDir, '.env');\n     let envContent = await fs.readFile(envPath, 'utf-8').catch(() => '');\n     \n     // Check if key already exists\n     const regex = new RegExp(`^${key}=.*`, 'm');\n     if (regex.test(envContent)) {\n       // Update existing key\n       envContent = envContent.replace(regex, `${key}=${value}`);\n     } else {\n       // Add new key\n       envContent += `\\n${key}=${value}`;\n     }\n     \n     await writeFile(envPath, envContent);\n     \n     // Update env.ts file with typed access\n     const envTypesPath = path.join(projectDir, 'env.ts');\n     let envTypesContent = await fs.readFile(envTypesPath, 'utf-8').catch(() => {\n       return `import { z } from 'zod';\\n\\nexport const envSchema = z.object({\\n  // Add your environment variables here\\n});\\n\\ndeclare global {\\n  namespace NodeJS {\\n    interface ProcessEnv extends z.infer<typeof envSchema> {}\\n  }\\n}\\n`;\n     });\n     \n     // Add key to envSchema if not already present\n     if (!envTypesContent.includes(`  ${key}:`)) {\n       envTypesContent = envTypesContent.replace(\n         'export const envSchema = z.object({',\n         `export const envSchema = z.object({\\n  ${key}: z.string(),`\n       );\n     }\n     \n     await writeFile(envTypesPath, envTypesContent);\n     \n     console.log(`✅ Added environment variable: ${key}`);\n   }\n   \n   export async function setupEnvValidation(): Promise<void> {\n     console.log('Setting up environment variable validation...');\n     \n     const projectDir = process.cwd();\n     \n     // Install zod if not already installed\n     const packageJsonPath = path.join(projectDir, 'package.json');\n     const packageJson = await fs.readJson(packageJsonPath);\n     \n     if (!packageJson.dependencies.zod) {\n       await execa('pnpm', ['add', 'zod'], { stdio: 'inherit' });\n     }\n     \n     // Create env.ts file\n     const envTypesPath = path.join(projectDir, 'env.ts');\n     const envTypesContent = `import { z } from 'zod';\\n\\nexport const envSchema = z.object({\\n  // Add your environment variables here\\n});\\n\\ndeclare global {\\n  namespace NodeJS {\\n    interface ProcessEnv extends z.infer<typeof envSchema> {}\\n  }\\n}\\n\\n// Validate environment variables at runtime\\nexport function validateEnv() {\\n  try {\\n    envSchema.parse(process.env);\\n  } catch (error) {\\n    console.error('❌ Invalid environment variables:', error.errors);\\n    throw new Error('Invalid environment variables');\\n  }\\n}\\n`;\n     \n     await writeFile(envTypesPath, envTypesContent);\n     \n     // Update next.config.js to validate env in development\n     const nextConfigPath = path.join(projectDir, 'next.config.js');\n     let nextConfig = await fs.readFile(nextConfigPath, 'utf-8');\n     \n     if (!nextConfig.includes('validateEnv')) {\n       nextConfig = nextConfig.replace(\n         'const nextConfig = {',\n         `const { validateEnv } = require('./env');\\n\\n// Validate environment variables in development\\nif (process.env.NODE_ENV === 'development') {\\n  validateEnv();\\n}\\n\\nconst nextConfig = {`\n       );\n     }\n     \n     await writeFile(nextConfigPath, nextConfig);\n     \n     console.log('✅ Set up environment variable validation');\n   }\n   ```\n2. Create templates for environment configuration in the templates package\n3. Implement typed environment variable access using Zod for validation\n4. Add support for different environment files (.env.development, .env.production, etc.)\n5. Implement environment variable validation at runtime\n6. Add documentation for environment variable usage in the generated code\n7. Implement error handling and validation",
        "testStrategy": "Test the environment management module with different key-value pairs. Verify the .env file is correctly updated with new and existing keys. Test the typed access generation with various environment variables. Ensure the validation works correctly by testing with valid and invalid environment configurations.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Custom Feature Scaffolding",
        "description": "Develop the feature scaffolding module that allows developers to create custom features with components, hooks, and API routes.",
        "details": "1. Create the feature scaffolding module in the CLI package:\n   ```typescript\n   // src/features/feature.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { renderTemplate, createDirectory, writeFile } from '@oneship/core';\n   \n   export async function addFeature(name: string): Promise<void> {\n     console.log(`Adding feature: ${name}`);\n     \n     // Validate feature name\n     if (!name) {\n       throw new Error('Feature name is required');\n     }\n     \n     // Convert to kebab-case for directory and pascal case for component names\n     const kebabName = name.toLowerCase().replace(/\\s+/g, '-');\n     const pascalName = name\n       .split(/[-\\s]+/)\n       .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n       .join('');\n     \n     const projectDir = process.cwd();\n     const featureDir = path.join(projectDir, 'features', kebabName);\n     \n     // Check if feature already exists\n     if (await fs.pathExists(featureDir)) {\n       throw new Error(`Feature ${name} already exists`);\n     }\n     \n     // Create feature directory structure\n     await createDirectory(featureDir);\n     await createDirectory(path.join(featureDir, 'components'));\n     await createDirectory(path.join(featureDir, 'hooks'));\n     await createDirectory(path.join(featureDir, 'api'));\n     await createDirectory(path.join(featureDir, 'utils'));\n     \n     // Create index.ts file\n     const indexContent = `// Export all components and hooks from the ${name} feature\\nexport * from './components';\\nexport * from './hooks';\\n`;\n     await writeFile(path.join(featureDir, 'index.ts'), indexContent);\n     \n     // Create components index.ts file\n     const componentsIndexContent = `// Export all components from the ${name} feature\\nexport * from './${pascalName}';\\n`;\n     await writeFile(path.join(featureDir, 'components', 'index.ts'), componentsIndexContent);\n     \n     // Create main component file\n     const componentContent = `import React from 'react';\\n\\ninterface ${pascalName}Props {\\n  // Add props here\\n}\\n\\nexport const ${pascalName}: React.FC<${pascalName}Props> = (props) => {\\n  return (\\n    <div className=\"${kebabName}-container\">\\n      <h2>${name}</h2>\\n      {/* Add your component content here */}\\n    </div>\\n  );\\n};\\n`;\n     await writeFile(path.join(featureDir, 'components', `${pascalName}.tsx`), componentContent);\n     \n     // Create hooks index.ts file\n     const hooksIndexContent = `// Export all hooks from the ${name} feature\\nexport * from './use${pascalName}';\\n`;\n     await writeFile(path.join(featureDir, 'hooks', 'index.ts'), hooksIndexContent);\n     \n     // Create main hook file\n     const hookContent = `import { useState, useEffect } from 'react';\\n\\nexport function use${pascalName}() {\\n  const [data, setData] = useState(null);\\n  const [loading, setLoading] = useState(false);\\n  const [error, setError] = useState(null);\\n\\n  useEffect(() => {\\n    // Add your hook logic here\\n  }, []);\\n\\n  return { data, loading, error };\\n}\\n`;\n     await writeFile(path.join(featureDir, 'hooks', `use${pascalName}.ts`), hookContent);\n     \n     // Create API route if using app router\n     const appApiDir = path.join(projectDir, 'app', 'api', kebabName);\n     if (await fs.pathExists(path.join(projectDir, 'app'))) {\n       await createDirectory(appApiDir);\n       \n       const apiRouteContent = `import { NextRequest, NextResponse } from 'next/server';\\n\\nexport async function GET(request: NextRequest) {\\n  try {\\n    // Add your API logic here\\n    return NextResponse.json({ message: '${pascalName} API' });\\n  } catch (error) {\\n    return NextResponse.json({ error: error.message }, { status: 500 });\\n  }\\n}\\n\\nexport async function POST(request: NextRequest) {\\n  try {\\n    const body = await request.json();\\n    // Add your API logic here\\n    return NextResponse.json({ message: '${pascalName} created' });\\n  } catch (error) {\\n    return NextResponse.json({ error: error.message }, { status: 500 });\\n  }\\n}\\n`;\n       await writeFile(path.join(appApiDir, 'route.ts'), apiRouteContent);\n     }\n     \n     // Create utils file\n     const utilsContent = `// Utility functions for the ${name} feature\\n\\nexport function format${pascalName}Data(data: any) {\\n  // Add your utility logic here\\n  return data;\\n}\\n`;\n     await writeFile(path.join(featureDir, 'utils', 'index.ts'), utilsContent);\n     \n     console.log(`✅ Added feature: ${name}`);\n     console.log(`Feature directory: ${featureDir}`);\n     console.log(`Import the feature components with: import { ${pascalName} } from '@/features/${kebabName}';`);\n   }\n   ```\n2. Create templates for feature scaffolding in the templates package\n3. Implement support for different feature types (page, component, API, etc.)\n4. Add support for generating test files for components and hooks\n5. Implement support for generating documentation for features\n6. Add support for generating TypeScript interfaces and types\n7. Implement error handling and validation",
        "testStrategy": "Test the feature scaffolding module with different feature names and types. Verify the correct directory structure and files are created. Test the generated code for syntax errors and TypeScript compatibility. Ensure the feature can be imported and used in a Next.js application.",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Plugin System",
        "description": "Develop the plugin system that allows developers to extend the CLI with custom commands and templates.",
        "details": "1. Create the plugin system module in the CLI package:\n   ```typescript\n   // src/plugins/index.ts\n   import path from 'path';\n   import fs from 'fs-extra';\n   import { Command } from 'commander';\n   \n   export interface Plugin {\n     name: string;\n     description: string;\n     commands?: PluginCommand[];\n     templates?: PluginTemplate[];\n   }\n   \n   export interface PluginCommand {\n     name: string;\n     description: string;\n     action: (options: any) => Promise<void>;\n     options?: PluginCommandOption[];\n   }\n   \n   export interface PluginCommandOption {\n     flags: string;\n     description: string;\n     defaultValue?: any;\n   }\n   \n   export interface PluginTemplate {\n     name: string;\n     path: string;\n   }\n   \n   export async function loadPlugins(program: Command): Promise<Plugin[]> {\n     const projectDir = process.cwd();\n     const pluginsDir = path.join(projectDir, '.oneship');\n     \n     if (!await fs.pathExists(pluginsDir)) {\n       return [];\n     }\n     \n     const pluginFiles = await fs.readdir(pluginsDir);\n     const plugins: Plugin[] = [];\n     \n     for (const file of pluginFiles) {\n       if (file.endsWith('.js') || file.endsWith('.ts')) {\n         try {\n           const pluginPath = path.join(pluginsDir, file);\n           const plugin = require(pluginPath).default as Plugin;\n           \n           if (!plugin || !plugin.name) {\n             console.warn(`Invalid plugin in ${file}: missing name property`);\n             continue;\n           }\n           \n           // Register plugin commands\n           if (plugin.commands) {\n             for (const command of plugin.commands) {\n               const cmd = program.command(command.name).description(command.description);\n               \n               // Add command options\n               if (command.options) {\n                 for (const option of command.options) {\n                   cmd.option(option.flags, option.description, option.defaultValue);\n                 }\n               }\n               \n               // Set command action\n               cmd.action(command.action);\n             }\n           }\n           \n           plugins.push(plugin);\n           console.log(`Loaded plugin: ${plugin.name}`);\n         } catch (error) {\n           console.error(`Error loading plugin from ${file}:`, error);\n         }\n       }\n     }\n     \n     return plugins;\n   }\n   \n   export async function createPlugin(name: string): Promise<void> {\n     console.log(`Creating plugin: ${name}`);\n     \n     // Validate plugin name\n     if (!name) {\n       throw new Error('Plugin name is required');\n     }\n     \n     const projectDir = process.cwd();\n     const pluginsDir = path.join(projectDir, '.oneship');\n     await fs.ensureDir(pluginsDir);\n     \n     const pluginPath = path.join(pluginsDir, `${name}.ts`);\n     \n     // Check if plugin already exists\n     if (await fs.pathExists(pluginPath)) {\n       throw new Error(`Plugin ${name} already exists`);\n     }\n     \n     // Create plugin template\n     const pluginTemplate = `import { Plugin } from 'oneship';\n\nconst ${name}Plugin: Plugin = {\n  name: '${name}',\n  description: '${name} plugin for OneShip',\n  commands: [\n    {\n      name: '${name}',\n      description: 'Run ${name} command',\n      options: [\n        {\n          flags: '--option <value>',\n          description: 'An example option',\n          defaultValue: 'default'\n        }\n      ],\n      action: async (options) => {\n        console.log('Running ${name} command with options:', options);\n        // Add your command logic here\n      }\n    }\n  ],\n  templates: [\n    {\n      name: '${name}',\n      path: './templates/${name}'\n    }\n  ]\n};\n\nexport default ${name}Plugin;\n`;\n     \n     await fs.writeFile(pluginPath, pluginTemplate);\n     \n     // Create templates directory for the plugin\n     const templatesDir = path.join(pluginsDir, 'templates', name);\n     await fs.ensureDir(templatesDir);\n     \n     // Create example template file\n     const exampleTemplatePath = path.join(templatesDir, 'example.ts');\n     const exampleTemplate = `// Example template for ${name} plugin\nexport const exampleComponent = \\`\nimport React from 'react';\n\nexport const Example = () => {\n  return (\n    <div>\n      <h1>${name} Example</h1>\n    </div>\n  );\n};\n\\`;\n`;\n     \n     await fs.writeFile(exampleTemplatePath, exampleTemplate);\n     \n     console.log(`✅ Created plugin: ${name}`);\n     console.log(`Plugin file: ${pluginPath}`);\n     console.log(`Templates directory: ${templatesDir}`);\n   }\n   ```\n2. Update the main CLI entry point to load plugins:\n   ```typescript\n   // src/index.ts\n   import { loadPlugins } from './plugins';\n   \n   // After registering built-in commands\n   loadPlugins(program).catch(error => {\n     console.error('Error loading plugins:', error);\n   });\n   ```\n3. Create a command to create new plugins:\n   ```typescript\n   // src/commands/plugin.ts\n   import { Command } from 'commander';\n   import { createPlugin } from '../plugins';\n   \n   export function registerPluginCommand(program: Command): void {\n     const plugin = program.command('plugin');\n     \n     plugin.command('create')\n       .description('Create a new plugin')\n       .argument('<name>', 'Plugin name')\n       .action(async (name) => {\n         await createPlugin(name);\n       });\n   }\n   ```\n4. Implement plugin discovery and loading mechanism\n5. Add support for plugin templates and commands\n6. Implement plugin validation and error handling\n7. Add documentation for creating and using plugins",
        "testStrategy": "Test the plugin system by creating and loading custom plugins. Verify that plugin commands are correctly registered and executed. Test plugin templates by generating code from them. Ensure error handling works correctly for invalid plugins. Test the plugin creation command with different plugin names.",
        "priority": "low",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-15T19:14:07.600Z",
      "updated": "2025-06-21T05:35:54.259Z",
      "description": "Tasks for master context"
    }
  }
}